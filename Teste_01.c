#pragma config(Sensor, S1,     Gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S2,     UltraDireita,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     UltraFrente,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          Lampada,       tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          MotorDireita,  tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          MotorEsquerda, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////
int gyr = 0;
int velocidadeMaxima = 70;
//int TurnRatio = 0;
//int Speed = 0;//0 a 100
int i = 0;
int ok = 1;
float oposto = 0;
float encoder = 0;
float sensorUltra = 0;
int referencia = 0;

const float PrimeiraReta = 1.90;    // MODIFICAR
const float SegundaReta = 1.00;     // MODIFICAR
const float TerceiraReta = 28.8;     // MODIFICAR

const float distanciaDaPrimeiraVolta = PrimeiraReta*360/(PI*0.16);
const float distanciaDaSegundaVolta = SegundaReta*360/(PI*0.16);
const float distanciaDaTerceiraVolta = TerceiraReta*360/(PI*0.16);
/*
float distancia1=0.5;
long anguloP2 = 45;
const float graus1 = distancia1*360/(PI*0.16);

float distancia2=0.5;
const float graus2 = distancia2*360/(PI*0.16);
*/

//PROTOTIPOS
void frente(int TurnRatio, int Speed);
void gira(long angulo, int VelocidadeGirar);
void Parar();


task main()
{
	frente(100,10);
	//resetGyro(S1);
	//resetMotorEncoder(motorB);
	//gyr = SensorValue[Gyro];
	//displayBigTextLine(1, "%i", gyr);

	/*
	while(getMotorEncoder(motorB)<graus1){
	frente(0,50);
	}
	Parar();

	gira(anguloP2,10);

	Parar();

	while(getMotorEncoder(motorB)<graus2){
	frente(0,50);
	}
	Parar();
	*/
	//while(1)
	//{
	//	gyr = SensorValue[Gyro];
	//	displayBigTextLine(1, "%i", gyr);
	//	frente(100,10);

	//}
	//while(getMotorEncoder(motorB)<distanciaDaPrimeiraVolta)
	//{
	//	frente(0,20);
	//}
	//Parar();
	//gyr = SensorValue[Gyro];
	//gyr = gyr - 90;
	//while(SensorValue[Gyro]>gyr)
	//{
	//	frente(100,10);
	//}
	//Parar();
	//resetMotorEncoder(motorB);
	//while(getMotorEncoder(motorB)<distanciaDaSegundaVolta)
	//{
	//	frente(0,20);
	//}
	//Parar();

	/*Marca que chegou no terreno
	wait1Msec(1000);
	setLEDColor(ledGreenFlash);
	*/

	/*
	while(1){
	sensorUltra = SensorValue(UltraDireita);
	displayBigTextLine(3, "%i", sensorUltra);
	}




	while(getMotorEncoder(motorB)<graus1){
	Speed = 50;
	frente();
	}

	TurnRatio = 100;
	frente();
	wait1Msec(1000);

	TurnRatio = 0;
	resetMotorEncoder(motorB);
	while(getMotorEncoder(motorB)<graus2){
	Speed = 50;
	frente();
	}

	Speed = 0;
	frente();
	sleep(1000);

	for(i=10;i<100;i++){
	encoder = getMotorEncoder(motorB);
	displayBigTextLine(5, "%f", encoder);
	Speed = i;
	frente();
	while(getMotorEncoder(motorB) < (encoder+10)){}
	}

	displayBigTextLine(3, "%f", encoder);

	//

	for(i=100;i>0;i--){
	Speed = i;
	frente();
	sleep(10);
	}*/
}
//FIM DO main()

void frente(int TurnRatio, int Speed)
{
	setMotorSync(motorB, motorC, TurnRatio, Speed);
}

void gira(long angulo, int VelocidadeGirar)
{
	referencia = SensorValue[Gyro];

	if(referencia<=90)
	{
		oposto = referencia+90;
	}
	else
	{
		oposto = referencia-90;
	}

	if(referencia>=angulo)
	{
		if(oposto>angulo)
		{
			frente(100,VelocidadeGirar);
		}
		else
		{
			frente(-100,VelocidadeGirar);
		}
	}
	else
	{
		if(oposto>angulo)
		{
			frente(-100,VelocidadeGirar);
		}
		else
		{
			frente(100,VelocidadeGirar);
		}
	}

	while(ok)
	{
		if((SensorValue[Gyro]<(gyr+2)) & (SensorValue[Gyro]>(gyr-2)))
		{
			ok=0;
		}
		setLEDColor(ledGreenFlash);
	}

	setLEDColor(ledOff);
	Parar();

}

void Parar()
{
	frente(0,0);
}
